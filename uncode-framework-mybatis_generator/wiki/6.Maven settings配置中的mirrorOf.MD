使用maven时，从来没仔细注意过setting配置节点的作用，直到今天配置总是不起作用，总是报错才开始去认识这些节点的含义。


这里就说mirrorOf，因为其他的怎么配置基本上都不会出错，只有mirrorOf会导致莫名其妙的错误，如果你还不了解mirrorOf，请往下看，你会认识到mirrorOf的重要作用的。


主要参考来自：

Using Mirrors for Repositories 

如果你英文很不错，你可以去maven官方查看上面的介绍，上面的介绍主要说明了mirrorOf的用法和作用。


或者在这里继续看下去：

先说mirrors中mirror的作用，mirrors允许配置多个镜像mirror，mirror的作用一般是为了使用一个更快速度的镜像，主要是访问速度的考虑，或者突破屏蔽使用可以访问的镜像。


在maven中不配置mirror时使用的maven的中央库。


在maven中配置一个mirror时，mirror通常会设置成*，还有可能是一个具体的值，还有可能是逗号隔开的几个值..

例如:

1.*

2.repo3

3.repo1,repo2,*,!repo3

4.external:*

在上面4个例子中，第一个例子中*的意思就是（根据mirrorOf和repository的id）匹配所有的库（repository），这样就是说如果你需要某个jar，他会从镜像地址去下载这个jar。不管你配置了多少个库，即使这些库的地址不一样，仍然会从镜像地址访问，这里就产生了问题。

问题：为什么我配置好了库（repository），但是下载不下来（或者下载地址不对）？

这个问题已经很明白了，就是镜像（mirror）的问题。

问题：如何解决上述问题呢？

这里请继续看第二个例子和第三个例子。


第二个例子只配置了一个repo3，这个镜像只能匹配id是repo3的库，该库会使用repo3的镜像访问。这里说重点了，即使还存在一个*的，这里会先查找完全相同的存储库标识符匹配的镜像，如果找到了，就用匹配的，这里就是repo3，这点可以放心。如果找不到，那就去根据其他的mirrorOf查找去，查找到一个就使用。这里需要注意的是，如果存在多个重复的mirrorOf，只会用排名靠前的第一个（按照配置顺序来）。如果一个都没有，就会用maven中央库。


第三个例子是用逗号隔开的好几个，并且有一个特殊的!repo3，一般!的意思是非，这里的意思就是，就是排除repo3的情况。综合起来第三个的含义就是完全匹配repo1,repo2和其他全部库，排除repo3库。


到这里，第二个问题已经有了答案，给这个库配置单独的镜像，而且位置尽量在前面，id和mirrorOf一致。说到这两个一致，还得说两个不能一致的情况，就是mirror的mirrorOf不能和任何mirror的id一致，因为id在setting中唯一，mirrorOf要和库的id一致，所以势必不能和mirror的id一致，如果一致显然就起不到作用了（这里属于猜测，官方要求不能一致）。


第四个例子很特殊，含义就是匹配本地库之外的全部库。如果本地库存在，就用本地库的。


到这里，有关mirrorOf的内容说完了。

记录下我解决问题的思路和原因以及解决办法，希望对你有所帮助。